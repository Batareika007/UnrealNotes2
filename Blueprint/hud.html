<div class="warning-green">
готово
</div>
<h1>HUD — Heads-Up Display</h1>

<p>
    <b>HUD</b> — это интерфейс, который отображается поверх игрового мира.  
    Он показывает игроку важную информацию:
</p>

<ul>
    <li>здоровье;</li>
    <li>патроны;</li>
    <li>стамину;</li>
    <li>время раунда;</li>
    <li>квесты;</li>
    <li>компас, мини-карта;</li>
    <li>уведомления и подсказки.</li>
</ul>

<p>
    HUD — это всегда <b>Widget Blueprint</b>, который добавляется на экран через Player Controller или другой актор.
</p>

<hr>

<h2>0. Где правильно создавать HUD</h2>

<p>
    При смене уровней через <b>Open Level</b> объекты <b>PlayerController</b> и <b>Pawn</b> уничтожаются и создаются заново.  
    Поэтому, если создавать HUD внутри PlayerController, он будет исчезать при переходе на другой уровень.
</p>

<p>
    Чтобы HUD сохранялся между уровнями, используется правильная архитектура:
</p>

<ul>
    <li><b>GameInstance</b> — создаёт HUD один раз и хранит ссылку на него.</li>
    <li><b>PlayerController</b> или <b>GameMode</b> — добавляют HUD на экран (Add to Viewport).</li>
</ul>

<p>
    GameInstance живёт всю игру и не уничтожается при смене уровней, поэтому HUD, созданный там, остаётся тем же самым.  
    Любой актор может получить доступ к HUD через <b>Cast to GameInstance</b>.
</p>

<hr>

<h2>1. Создание HUD Widget</h2>

<p>
    Создаём обычный <b>User Widget</b> (например, <b>HUD_Main</b>).  
    Внутри размещаем элементы интерфейса: текст, полосы здоровья, иконки, таймеры.
</p>

<p>
    HUD создаётся в GameInstance, но показывается на экране из PlayerController.
</p>

<img src="Blueprint/images/hud.png" alt="">

<ol>
    <li>В GameInstance создаём переменную <b>HUDWidgetInstance</b>.</li>
    <li>При старте игры создаём виджет (Create Widget) и сохраняем его в GameInstance.</li>
    <li>В PlayerController (BeginPlay) получаем HUD из GameInstance и вызываем <b>Add to Viewport</b>.</li>
</ol>

<p>
    Такой подход гарантирует, что HUD не исчезнет при смене уровней.
</p>

<hr>

<h2>2. Удаление HUD</h2>

<p>
    Есть два способа удалить виджет:
</p>

<ul>
    <li><b>Remove from Parent</b> — удаляет конкретный виджет, на который есть ссылка.</li>
    <li><b>Remove All Widgets</b> — удаляет все виджеты на экране.</li>
</ul>

<img src="Blueprint/images/hud2.png" alt="">

<p>
    <b>Remove All Widgets</b> удобно использовать при смене уровня или при смерти игрока.  
    Но для обычной логики лучше использовать <b>Remove from Parent</b>.
</p>

<hr>

<h2>3. Фокус и управление вводом</h2>

<p>
    Виджет может получать ввод с клавиатуры или мыши, если он имеет <b>фокус</b>.
</p>

<img src="Blueprint/images/hud3.png" alt="">

<p>
    Если фокус есть:
</p>

<ul>
    <li>клавиши идут в UI;</li>
    <li>кнопки работают;</li>
    <li>можно вводить текст;</li>
    <li>игрок не управляет персонажем (если Input Mode = UI Only).</li>
</ul>

<p>
    Если фокуса нет:
</p>

<ul>
    <li>ввод идёт в игру;</li>
    <li>UI не реагирует на клавиши;</li>
    <li>мышь может быть скрыта.</li>
</ul>

<p>
    Управление вводом делается через Player Controller:
</p>

<ul>
    <li><b>Set Input Mode Game Only</b></li>
    <li><b>Set Input Mode UI Only</b></li>
    <li><b>Set Input Mode Game and UI</b></li>
</ul>

<p>
    Это важно для меню, паузы, инвентаря, диалогов.
</p>

<hr>

<h2>4. Как обновлять HUD (здоровье, патроны, время)</h2>

<p>
    Есть три основных способа обновлять HUD:
</p>

<h3>Способ 1 — Bindings (простой, но медленный)</h3>

<p>
    В Widget можно привязать текст или прогрессбар к переменной.  
    Но Bindings вызываются каждый кадр, поэтому они медленные.
</p>

<p><b>Рекомендуется избегать Bindings в больших проектах.</b></p>

<hr>

<h3>Способ 2 — Event Dispatchers (лучший вариант)</h3>

<p>
    Персонаж вызывает событие → HUD обновляет UI.  
    Это быстрый и чистый способ.
</p>

<hr>

<h3>Способ 3 — Прямой доступ через переменную</h3>

<p>
    Если HUD сохранён в GameInstance, любой актор может обновлять его напрямую:
</p>

<ul>
    <li>HUD → Set Health</li>
    <li>HUD → Set Ammo</li>
</ul>

<p>
    Это тоже хороший вариант.
</p>

<hr>

<h2>5. Где лучше показывать HUD?</h2>

<p>
    HUD создаётся в GameInstance, но показывается на экране через <b>PlayerController</b>.
</p>

<p>
    Почему:
</p>

<ul>
    <li>PlayerController управляет вводом;</li>
    <li>PlayerController существует на клиенте;</li>
    <li>PlayerController отвечает за UI Mode;</li>
    <li>HUD должен принадлежать игроку, а не уровню.</li>
</ul>

<p>
    Но в простых проектах можно показывать HUD прямо из персонажа.
</p>

<hr>

<h2>6. Когда HUD не работает?</h2>

<p>
    Возможные причины:
</p>

<ul>
    <li>виджет не добавлен в Viewport;</li>
    <li>виджет добавлен, но скрыт (Set Visibility Hidden);</li>
    <li>виджет добавлен в неправильный Player Controller;</li>
    <li>виджет не имеет фокуса, если нужен ввод;</li>
    <li>HUD создаётся до того, как Player Controller появился;</li>
    <li>HUD создаётся на сервере, а не на клиенте (в мультиплеере).</li>
</ul>

<hr>

<h2>7. Лучшие практики</h2>

<ul>
    <li>Создавай HUD в GameInstance, чтобы он не исчезал между уровнями.</li>
    <li>Показывай HUD через PlayerController.</li>
    <li>Используй Event Dispatchers для обновления UI.</li>
    <li>Избегай Bindings в больших проектах.</li>
    <li>Храни ссылку на HUD в GameInstance.</li>
    <li>Используй Input Mode для меню и UI.</li>
    <li>Не добавляй HUD несколько раз — проверяй, существует ли он.</li>
</ul>

<p>
    HUD — это основа UX/UI. Правильная архитектура делает игру удобной, понятной и профессиональной.
</p>
