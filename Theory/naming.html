<div class="warning-yellow">
нужно отредактировать описания, можно пользоваться
</div>
<h1>Базовые элементы движка</h1>
<!-- Object -->
<h2>Object</h2>
<p> Объекты являются самым базовым классом в Unreal Engine — другими словами, они действуют как строительные блоки и содержат множество основных функций для ваших Assets. Почти все в Unreal Engine наследует (или получает некоторую функциональность) от Object. </p>
<details>
  <summary>Больше от ИИ</summary>
  <p>Object — самый базовый класс в Unreal Engine. Почти всё в движке наследуется от него.</p>
  <p>Object — это фундамент всей системы классов в Unreal Engine. Он содержит базовые функции, такие как управление памятью, сериализация и система отражения (Reflection), которые нужны большинству объектов.
Ты редко создаёшь Object напрямую, но почти каждый объект в игре так или иначе основан на нём.</p>
</details>
<!-- Class -->
<h2>Class</h2>
<p>
    Класс определяет поведение и свойства конкретного Актера или Объекта в Unreal Engine. Классы иерархичны, то есть Класс наследует информацию от своего родительского Класса (то есть Класса, от которого он был получен или «подклассифицирован») и передает эту информацию своим потомкам. Классы могут быть созданы в коде C++ или в Blueprints.
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p> Класс определяет свойства и поведение объекта. Классы могут наследовать друг друга.</p>
  <p>Класс — это шаблон, по которому создаются объекты. Он описывает, какие переменные и функции у них будут.</p>
<p>Классы образуют иерархию: дочерний класс получает всё от родительского и может добавлять своё. В Unreal классы можно создавать в C++ или в Blueprints — оба способа работают одинаково, просто один визуальный, другой кодовый.</p>
</details>
<!-- Actore -->
<h2>Actor</h2>
<p>
    Любой объект, который можно разместить на уровне, например, камера, статическая сетка или начальная позиция игрока. Актеры поддерживают 3D-преобразования, такие как перемещение, вращение и масштабирование. Их можно создавать и уничтожать с помощью игрового кода (C++ или Blueprints).    
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p>Actor — это объект, который можно разместить в игровом мире.</p>
  <p>
      Actor — это основной тип объекта, который существует на уровне (Level). Он имеет позицию, вращение и масштаб, и может взаимодействовать с другими объектами.
    Камеры, персонажи, предметы, триггеры — всё это актёры. Их можно создавать, удалять и изменять во время игры через Blueprints или C++.
  </p>
</details>
<!-- Cast -->
<h2>Cast</h2>
<p>
    Casting — это действие, которое берет Actor определенного класса и пытается обращаться с ним так, как будто он принадлежит к другому классу. Casting может быть успешным или неудачным. Если casting успешен, вы можете получить доступ к функциональности, специфичной для класса Actor, к которому вы его привели.
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p> Casting — это попытка обратиться к объекту как к другому классу.</p>
  <p>
      Casting используется, когда ты знаешь, что объект на самом деле является экземпляром определённого класса, и хочешь получить доступ к его уникальным функциям.
    Если приведение успешно — ты можешь работать с объектом как с нужным типом. Если нет — результат будет пустым, и нужно обработать ошибку. Это обычная часть работы в Blueprints.
  </p>
</details>
<!-- Component -->
<h2>Component</h2>
<p>
    Компонент — это часть функциональности, которую можно добавить к Актору.
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p>Компонент — это часть функциональности, которую можно добавить к актёру.</p>
  <p>
      Компоненты позволяют собирать актёров из отдельных “деталей”. Например, камера — это компонент. Коллайдер — компонент. Звук, частицы, логика движения — тоже компоненты.
    Они не существуют сами по себе, а всегда прикреплены к актёру, расширяя его возможности.
  </p>
</details>
<!-- Player State -->
<h2>Player State</h2>
<p>
    <span class="ui-btn">ТОЛЬКО в МНОГОПОЛЬЗОВАТЕЛЬСКОЙ игре</span>
    <br>Player State это состояние участника игры, например, игрока-человека или бота, который имитирует игрока. Неигровой ИИ, существующий как часть игрового мира, не имеет состояния игрока.
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p>Player State хранит информацию о конкретном игроке.</p>
  <p>Player State используется в играх, особенно сетевых, чтобы хранить данные, связанные с игроком: имя, счёт, команду, статус.</p>
<p>Он существует отдельно от Pawn или Controller, поэтому информация о игроке сохраняется даже если персонаж был уничтожен или заменён.</p>
</details>
<!-- Game state -->
<h2>Game State</h2>
<p>
    <span class="ui-btn">ТОЛЬКО в МНОГОПОЛЬЗОВАТЕЛЬСКОЙ игре</span>
    <br>
     State — это контейнер, содержащий информацию, которую вы хотите реплицировать для каждого клиента в игре. Проще говоря, это «Состояние игры» для всех подключенных. Вот некоторые примеры того, что может содержать Состояние игры: Информация об игровом счете. Начался ли матч или нет. Сколько персонажей ИИ создавать на основе количества игроков в мире. (только для многопользовательской игры)
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p>Game State хранит общую информацию о состоянии игры для всех игроков.</p>
  <p>Game State используется для данных, которые должны быть доступны всем клиентам в многопользовательской игре. Например: идёт ли матч, какой счёт, сколько осталось времени, сколько ИИ нужно создать.</p>
<p>Он синхронизируется между сервером и клиентами, обеспечивая одинаковое состояние игры для всех.</p>
</details>
<!-- World -->
<h2>World</h2>
<p>
    World— это контейнер для всех уровней, которые составляют вашу игру. Он управляет потоковой передачей уровней и порождением (созданием) динамических актеров
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p>World — это контейнер, в котором находятся уровни и актёры.</p>
  <p>World управляет всей игровой средой: загружает уровни, создаёт актёров, обрабатывает их обновление и взаимодействие.</p>
<p>Каждая игра имеет свой World, и именно он отвечает за то, что происходит в игровом пространстве — от потоковой загрузки уровней до спавна объектов.</p>

</details>

<!-- Pawn -->
<h2>Pawn</h2>
<p>
    Pawn - пешка
</p>
<details>
  <summary>Больше от ИИ</summary>
  <p>Pawn — объект, которым можно управлять.</p>
  <p>
      Pawn — это актёр, который может быть контролируем игроком или ИИ. Сам по себе Pawn ничего не делает, но служит “телом”, которым управляет PlayerController или AIController.
    Например, персонаж, машина, дрон — всё это Pawns.
  </p>

</details>

<!--Character  -->
<h2>Character</h2>
<p>character - продвинутя пешка которой управляет игрок</p>
<details>
    <summary>Больше от ИИ</summary>
    <p>Character — это Pawn с готовой системой движения.</p>
    <p>Character — это расширенный Pawn, который уже содержит капсулу-коллайдер, компонент движения и базовую логику ходьбы/прыжков.</p>
<p>Если ты делаешь игру от третьего или первого лица — почти всегда используешь Character.</p>
</details>

<!-- PlayerController -->
 <h2>PlayerController</h2>
 <p>Blueprints - в котором описывает управление</p>
<details>
    <summary>Больше от ИИ</summary>
    <p>PlayerController — объект, который управляет Pawn’ом игрока.</p>
    <p>PlayerController получает ввод (клавиатура, мышь, геймпад) и передаёт команды Pawn’у или Character’у.</p>
<p>Он существует даже если Pawn уничтожен — поэтому логика игрока не теряется.</p>
</details>
<!-- GameMode -->
 <h2>GameMode</h2>
 <p></p>
<details>
    <summary>Больше от ИИ</summary>
    <p>GameMode определяет правила игры.</p>
    <p>GameMode существует только на сервере и управляет тем, как начинается игра, какой Pawn создаётся для игрока, какой контроллер используется, что происходит при смерти персонажа и т. д.</p>
<p>В одиночной игре он тоже работает, просто как “локальный сервер”.</p>
</details>